# B-Tree Index

## Searching

1. Scan the index root
2. Find the leaf block
3. Search the value in the leaf

## A URL Shortener

- Create short URLs that redirect to longer URLs
- Keeps track of the number of clicks
- Common in SMS, Tweets
- Useful to keep track of campaigns

### Create table with 100 mil data

```sql
CREATE TABLE shorturl (
    id int generated by default as identity primary key,
    key varchar(10) not null unique,
    url text not null,
    hits int not null.
    created_at timestamptz not null,
    constraint hits_gte_zero_check check (hits >= 0)
);
```

### Find unused short URLs

let describe the table

```bash
db2=# \d shorturl
                                     Table "public.shorturl"
   Column   |           Type           | Collation | Nullable |             Default
------------+--------------------------+-----------+----------+----------------------------------
 id         | integer                  |           | not null | generated by default as identity
 key        | character varying(10)    |           | not null |
 url        | text                     |           | not null |
 hits       | integer                  |           | not null |
 created_at | timestamp with time zone |           | not null |
Indexes:
    "shorturl_pkey" PRIMARY KEY, btree (id)
    "shorturl_key_key" UNIQUE CONSTRAINT, btree (key)
Check constraints:
    "hits_gte_zero_check" CHECK (hits >= 0)

db2=#
```

explain table

```bash
db2=# explain (analyze, timing) select * from public.shorturl where hits=0;
                                                             QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------------
 Gather  (cost=1000.00..1561821.57 rows=99804 width=49) (actual time=3.327..22224.574 rows=100282 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   ->  Parallel Seq Scan on shorturl  (cost=0.00..1550841.17 rows=41585 width=49) (actual time=3.794..22200.131 rows=33427 loops=3)
         Filter: (hits = 0)
         Rows Removed by Filter: 33299906
 Planning Time: 0.196 ms
 Execution Time: 22227.365 ms
(8 rows)

db2=#
```

We can see that the query above performing full stable scan to find row where hits is 0 and here summary of the table is 100 mil rows

Performance Metrics:

- Total Execution Time: 22,227.365 ms (about 22.2 seconds)
- Rows Returned: 100,282 rows
- Total Table Rows: 33,427 + 33,299,906 = 33,333,333 rows (100000000)

Scan Type:

- Parallel Seq Scan (Sequential Scan)
- Uses 2 worker threads
- Scanned the entire table
- Filtered out 33,299,906 rows that did not match the condition

Performance Issues:

- Very slow query (22.2 seconds)
- Scans the entire table
- High number of rows removed by filter

Potential Optimization: The query would benefit from a B-tree index on the hits column. This would allow the database to quickly locate rows with hits=0 without scanning the entire table

```sql
CREATE INDEX idx_shorturl_hits ON public.shorturl (hits);
CREATE INDEX idx_shorturl_hits ON public.shorturl USING btree(hits);
```

We can omit `USING btree` since the default is btree

```bash
db2=# CREATE INDEX idx_shorturl_hits ON public.shorturl (hits);
CREATE INDEX
db2=#

db2=# explain (analyze, timing) select * from public.shorturl where hits=0;
                                                                  QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using idx_shorturl_hits on shorturl  (cost=0.57..382797.80 rows=99796 width=49) (actual time=0.912..15125.187 rows=100282 loops=1)
   Index Cond: (hits = 0)
 Planning Time: 4.471 ms
 Execution Time: 15144.049 ms
(4 rows)

db2=#
```

Let's analyze the new EXPLAIN ANALYZE result after creating the B-tree index on the hits column

Query Optimization Comparison:

- Before Index: 22,227.365 ms execution time
- After Index: 15,144.049 ms execution time
- Performance Improvement: ~32% faster (reduction of ~7,083 ms)

Scan Type Change:

- Before: Parallel Seq Scan (Full table scan)
- Now: Index Scan using idx_shorturl_hits

Key Observations:

- Cost estimate significantly reduced from 1,561,821.57 to 382,797.80
- Planning Time increased slightly (0.196 ms â†’ 4.471 ms)
- Still returns the same number of rows (100,282)

Index Scan Details:

- Uses the newly created B-tree index
- Direct condition matching: Index Cond: (hits = 0)
- More efficient row retrieval

The index has significantly improved query performance by allowing direct access to rows with hits=0 instead of scanning the entire table.

Still able to improve the query ...

How many unused short URLs do we have?

```bash
db2=# select count(*) from shorturl where hits=0;
 count
--------
 100282
(1 row)

db2=#

db2=# select count(*) from shorturl;
   count
-----------
 100000000
(1 row)

db2=#
```

There are 100282 row where hits=0 and 100000000 rows in total like 1% of the total rows

There are 3 things to note:

- Our index includes all the rows in the table
- We only care about a small portion of them
- Index only the portion we actually care about

```sql
CREATE INDEX idx_shorturl_unused_hits ON public.shorturl (id) where hits=0;
```

Index only short URLs with zero hits

```bash
db2=# CREATE INDEX idx_shorturl_unused_hits ON public.shorturl (id) where hits=0;
CREATE INDEX
db2=#

db2=# explain (analyze, timing) select * from public.shorturl where hits=0;
Index Scan using idx_shorturl_unused_hits on shorturl  (cost=0.29..3628.23 rows=99796 width=49) (actual time=1.639..14195.028 rows=100282 loops=1)
 Planning Time: 0.165 ms
 Execution Time: 14213.391 ms
(3 rows)
```

PostgreSQL is using the partial index

Partial Index Performance:

- Execution Time: 14,213.391 ms
- Previous Full Index: 15,144.049 ms
- Improvement: Additional ~6% performance gain (reduction of ~931 ms)

Key Changes:

- Index Type: Partial Index idx_shorturl_unused_hits
- Condition: Only indexes rows where hits = 0
- Indexed Column: id instead of hits

Cost Estimation:

- Previous Cost: 382,797.80
- New Cost: 3,628.23 (significant reduction)
- Planning Time: Dramatically reduced to 0.165 ms

Advantages of Partial Index:

- Smaller index size (only 100,282 rows instead of 100,000,000)
- Faster index creation and maintenance
- More efficient storage and query performance
- Targeted indexing for specific use cases

Performance Implications:

- Still returns all 100,282 rows
- More efficient index lookup
- Reduced index overhead

```bash
db2=# \di+ idx_*
                                                   List of relations
 Schema |           Name           | Type  |  Owner   |  Table   | Persistence | Access method |  Size   | Description
--------+--------------------------+-------+----------+----------+-------------+---------------+---------+-------------
 public | idx_shorturl_hits        | index | postgres | shorturl | permanent   | btree         | 661 MB  |
 public | idx_shorturl_unused_hits | index | postgres | shorturl | permanent   | btree         | 2208 kB |
(2 rows)

db2=#
```

## Partial Indexes

- Produce smaller indexes
- Limited to queries using the indexed rows
- Nullable columns are great candidates
- Use when possible
